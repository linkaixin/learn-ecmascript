<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Document</title>
</head>

<body>
    <div>高内聚低耦合</div>
    <div>实现一个模块的单一责任制，减少代码的冗余，提高代码的可维护性和可扩展性；</div>

    <div>函数的声明</div>
    <script>
        function 函数名(形参) {
            函数执行语句;
        }
    </script>
    <div>匿名函数表达式</div>
    <script>
        // fn在整个函数的运行中是可有可无的，但在函数体的内部是可以访问到的；
        var fn1 = function fn() {
            console.log('1');
            // fn();    // 调用函数本身，叫递归。但是这里确实结束调用的条件，所以会死循环；
        }
        fn1();
    </script>
    <script>
        var test = function a() {
            return 'a'
        }
        console.log(typeof (a), '------a()');
    </script>

    <div>函数调用才执行，不调用不执行</div>
    <script>
        function test() {
            console.log('test');
        }
        test();
        test();
        test();
    </script>
    <div>命名规则</div>
    <div>可以用字母、$、_开头</div>
    <div>不能用数字开头，但是可以包含数字</div>
    <div>使用小驼峰命名</div>

    <div>参数</div>
    <div>实参、形参；要一一对应</div>
    <script>
        // a,b 形参
        function fn2(a, b) {
            console.log(a, b);
        }
        // 1,5 实参
        fn2(1, 5)
    </script>
    <div>形参实参的数量可以不相等</div>
    <script>
        function fn3(a, b) {
            console.log(a, b);   // 1 undefined
        }
        fn3(1)

        function fn4(a, b) {
            console.log(a, b);   // 1 2
        }
        fn4(1, 2, 3, 4)
    </script>
    <div>形参实参的数量与值</div>
    <script>
        function fn5(a, b) {
            console.log(arguments, '实参的数组');   // [1, 2, 3, 4]
            console.log(fn5.length, '形参的数量');  // 2
        }
        fn5(1, 2, 3, 4)

        // 计算实参的总和
        function fn6() {
            let sum = 0;
            for (let i = 0; i < arguments.length; i++) {
                sum += arguments[i];
            }
            console.log(sum, '实参综合');
        }
        fn6(1, 2, 3, 4, 5, 6, 7, 8, 9)

        // 函数内部更改已传入实参的值
        function fn7(a, b) {
            a = 3;
            b = 3;
            // 这里更改了a，arguments中的值也变化
            // 但这两个不是同一个值，a，b存入栈内存，arguments数组存在堆内存，在栈内存中仅有地址
            // 但是能一起变化，证明是存在映射关系的
            console.log(arguments[0], arguments[1]);  // 3 undefined
        }
        fn7(1)
    </script>
    <div>return</div>
    <div>终止函数的进行</div>
    <div>返回响应的值，外部需要接收</div>
    <script>
        function fn8() {
            console.log(1); // 1
            return;
            console.log(2);
        }
        fn8();

        function fn9(name) {
            return name || '请输入名称';
        }
        fn9();
    </script>

    <div>函数作用域</div>
    <div>越里面的函数越能访问外部的变量</div>
    <script>
        a = 1;
        function test() {
            var b = 3;
            function test1() {
                var c = 5;
                console.log(a, b);  // 1 3
                a = 7;
            }
            console.log(a);     // 1
            test1();
        }
        console.log(a);     // 1
        // console.log(c);  // 报错
        test();
    </script>

    <div>作业</div>
    <div>1、接收一个符号，再接收两个数，返回计算结果（+ - * / %）</div>
    <script>
        function count(sign, num1, num2) {
            if (sign == '+') {
                return num1 + num2;
            } else if (sign == '-') {
                return num1 - num2;
            } else if (sign == '*') {
                return num1 * num2;
            } else if (sign == '/') {
                return num1 / num2;
            } else if (sign == '%') {
                return num1 % num2;
            } else {
                return '请写入正确的符号'
            }
        }
        console.log(count('%', 1, 5));
    </script>

</body>

</html>